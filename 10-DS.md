# 数据结构

## 学习方法

1. 勤于思考
2. 多做练习
3. 实操
4. 寻求帮助
5. 因难而上，坚持不懈



## 如何将新的、杂乱无章、具有一定结构的数据如何处理？

**逻辑结构：**研究对象的特性及其相互之间的关系；

**存储结构：**有效地组织计算机存储；

**算法：**有效地实现对象之间的“运算”关系。



## 第一章 绪论

![image-20220629161638681](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220629161638681.png)

### 名词解释

数据结构：是一门研究**非数值计算**的程序设计中计算机的**操作对象**以及它们之间的**关系**和**操作**的学科。



![image-20220627164319636](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220627164319636.png)





1. 数据：信息的载体，由描述客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称。
   1. 数值型：加工处理的对象——纯粹的数值。
   2. 非数值性：字符、表格、图像、声音
2. 数据项：构成数据元素的不可分割的最小单位；
3. 数据元素：数据的基本单位，通常作为一个整体进行考虑和处理。也称记录、结点或顶点、元素。**与数据的关系：是集合的个体**；
4. 数据对象：是性质相同的数据元素的集合，**与数据的关系：数据的一个子集** 。
5. 数据结构：数据元素不是孤立存在的，它们**相互之间存在一种或多种特定关系的数据元素的集合**。
6. **数据结构的三要素**
   1. 逻辑结构：描述数据元素之间的逻辑关系；
   2. 存储结构（物理结构）：数据元素及其组织方式
   3. 数据的运算和实现



**数据 > 数据元素 > 数据项**



### 逻辑结构

> 数据元素之间的逻辑的关系，与数据的存储无关，独立于计算机的



1. 线性结构：有且仅有一个开始和一个终点，并且所有结点最多只有一个直接前驱和一个直接后继。例如：线性表、栈、队列、串
2. 非线性结构：一个结点可能有多个直接前驱和直接后继。例如：树、图。



**逻辑结构其他划分方式**

1. 集合：结构中的数据元素之间**除了同属于一个集合的关系外，无任何其他关系**。
2. 线性：结构中的数据元素支架你存在着**一对一的线性关系**。
3. 树：结构中的数据元素之间存在着**一对多的层次关系**。
4. 图或网状结构：结构中的数据元素之间存在着**多对的任意关系**。





### 存储结构

> 数据结构在计算机中的表示（又称映像），也称物理结构。包括了数据元素的表示和关系的表示。
>
> 使用计算机语言实现的逻辑结构，依赖于计算机语言。



1. 顺序存储：用一组**连续**的存储单元一次存储数据元素，数据元素之间的逻辑关系有元素的存储位置来表示。**用前驱和后继的关系存储。**
2. 链式存储：用一组**任意**的存储单元存储数据元素，数据元素之间的逻辑关系用**指针**来表示。C语言中用指针来表示链式存储。
3. 索引存储：在存储结点信息的同时，还建立附加的**索引表**。索引表中的每一项称为一个索引项。
4. 散列（Hash）存储：根据结点的关键字直接计算出该结点的存储地址。



### 数据的运算

> 施加在数据上的运算包括运算的定义和实现；
>
> **运算的定义**是针对逻辑结构，指出运算的功能；
>
> **运算的实现**是针对存储结构，指出运算的具体操作步骤。



### 数据类型和抽象数据类型

#### 数据类型

> 数据类型：一组性质相同的**值的集合**以及定义于这个值集合上的**一组操作**的总称。
>
> 高级语言中数据类型**明显的或隐含的**规定了在程序执行期间变量和表达的所有可能的取值范围，以及在这些数值范围上所允许进行的操作。



**数据类型的作用**

1. 约束变量或常量的取值范围；
2. 约束变量或常量的操作；



#### 抽象数据类型

抽象数据类型**ADT**(Abstract Data Type)：一个数据模型以及定义在此数据模型上的一组操作。

1. 有用户定从问题中抽象出的数据模型（逻辑结构）
2. 还包括定义在数据模型上的一组抽象运算（相关操作）
3. **不考虑在计算机内的具体存储结构与运算的具体实现算法。**



#### ADT形式定义

抽象数据类型可用（D, S, P)三元组表示

1. D：数据对象；
2. S：D上的关系集；
3. P：对D的基本操作集。

~~~
ADT 抽象数据类型民 {
	数据对象：<数据对象的定义>
	数据关系：<数据关系的定义>
	基本操作：<基本操作的定义>
}ADT 抽象数据类型

数据对象、数据关系的的定义用伪代码描述
基本操作的定义格式为：

~~~

数据对象、数据关系的的定义用伪代码描述
基本操作的定义格式为：

1. 基本操作名（参数列表）
2. 初始条件：（初始化条件的描述）
3. 操作结果：（操作结构描述）



#### 基本操作定义格式说明

1. 参数表：
   1. 赋值参数：只为操作提供输入值；
   2. 应用参数用`&`开头，除可提供输入值外，还将返回操作结果。
2. 初始条件：描述操作执行之前数据结构和参数应满足的条件，若不满足，则操作失败，并返回相应出错信息。若初始条件为空，则省略之。
3. 操作结果：操作正常完成之后，数据结构的变化状况和应返回的结果。



#### 抽象数据类型（ADT）案列

~~~
ADT 抽闲数据类型名{
	Data 
		数据对象的定义
		数据元素之间逻辑关系的定义
	Opreation
		操作1
			初始条件
			操作结果描述
		操作2
			...
		操作n
}ADT 抽闲数据类型
~~~



**圆的定义**

~~~
ADT Circle{
	数据对象: D={r,x,y | r,x,y均为实数}
	数据关系: R={<r,x,y> |  r是半径, <x,y>是圆心坐标}
	基本操作:
	Circle(&C,r,x,y)
				操作结果：构造一个圆
	double Area(C)
	 			初始条件：圆已存在
	 			操作结果：计算面积
	double Circumference(C)
				初始条件：圆已存在
				操作结果：计算周长
}ADT Circle
~~~



**复数的定义**

~~~
ADT Complex{
	D = {r1, r2 | r1, r2都是实数}
	D = {<r1, r2> | r1实部, r2虚部}
	assign(&C, v1, v2)
		初始条件：空的复数C已存在
		操作结果：构造复数C，r1，r2分别被赋以参数v1, v2的值
	destory(&C)
		初始条件：复数C已存在
		操作结果：复数C被销毁
	GetReal(Z, &realPart)
		初始条件：复数C已存在
		操作结果：用realPart返回复数Z的实部值
	GetImag(Z, &imagPart)
		初始条件：复数C已存在
		操作结果：用imagePart返回复数Z的虚部值
	Add(z1, z2, &sum)
		初始条件：z1,z2是复数
		操作结果：用sum返回两个复数z1,z2的和
}ADT Complex
~~~



### 算法和算法分析

> 算法的定义：对特定问题**求解方法和步骤**的一种描述，是一个有限长操作序列。



**算法的五个特性：**

1. 有穷性：算法能在有穷步后结束，能在有穷时间内完成；
2. 确定性：算法中的每条指令都有确切的含义——无二义性，相同的输入只能得到相同的输出；
3. 可行性：所有操作都可以通过以及实现的基本操作运算执行有限次来实现；
4. 输入：有零个或多个输入；
5. 输出：有一个或多个输出；

算法在保证基本的标准：**正确性、健壮性、可读性、高效性**的基础上，应考虑算法的效率，通过算法的高来评判不同算法的优劣程度。





算法效率的考虑的两个方面：

1. 时间效率：算法执行所耗费的时间；
2. 空间效率：算法执行过程中耗费的存储空间。

**时间和空间往往是矛盾的**



#### 时间复杂度

算法时间效率的度量

1. 算法时间效率可用依据该算法编制的程序在计算机上执行所有耗费时间度量。
   1. 事后统计：实现算法，测算其时间和空间开销
   2. 事前分析：对算法所消耗资源的一种估算方法。



**事前分析方法**

```
算法运行时间=一个简单操作所需的时间x简单操作次数

算法运行时间 = 每条语句的频度 x 该语句执行一次所需要的时间
```



**执行一次所需的时间**

每条语句执行一次所需的时间，一般是随机器而异的。取决于机器的指令性能、速度以及编译的代码质量。是由机器本身软硬件环境决定的，与算法无关。



**算法时间复杂度的渐进表示法**

若有某个辅助函数f(n)，是的当n趋近于无穷大时，T(n)/f(n)的极限值为**不等于零的常数**，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，记作T(n)=O(f(n))，成O(f(n))为算法的**渐进时间复杂度**(O是数量级的符号)，简称**时间复杂度**。

渐进时间复杂度，来表示语句频度的数量级。



**基本语句**：为了客观的反映一个算法的执行时间，可以只用算法中的”基本语句“的执行次数来度量算法的工作量。

**”基本语句“是指算法中重复执行次数与算法的执行时间成正比的语句，并且它对算法运行时间的共享最大。**



**常见的渐进时间复杂度**

![image-20220628155615838](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220628155615838.png)



#### 空间复杂度

**算法要占据的空间**

1. 算法本身要占据的空间，输入/输出、指令、常数、变量等；
2. 算法需要要使用的**辅助空间**，如对一些数据进程操作时产生的辅助空间。



注意：

**算法原地工作**: 是指算法所需的辅助空间是常量，即O(1);



### 平均查找长度ASL

**平均查找长度ASL（Average Search Length）**为确定记录在表中的位置，需要给定值比较的关键字的个数的期望值叫做查找算法的平均查找长度。
$$
ASL =   \sum_{i=1}^n P_iC_i
$$



### 设计算法的过程

抽象数据类型 =  数据的逻辑结构 + 抽象运算 （运算的功能描述）



## 第二章 线性表

> 线性表：具有相同特性的数据元素的一个有限序列。 
>
> 逻辑基本特点： 除第一个和最后一个元素之外，其他每个元素都有唯一的直接前驱和直接后继。



从具体应用中抽象出共性的**逻辑结构和基本操作**（抽象数据类型），然后实现其**存储结构和基本操作**。

  

顺序存储结构存在问题

1. 存储空间分配不灵活；
2. 运算的空间复杂度高。



### 线性表的表示和实现

### 顺序存储实现

> 顺序存储定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中存储结构。
>
> 特点：占用一片连续的存储空间，知道某个元素的存储位置就可以计算其他元素的存储位置；
>
> 逻辑顺序与其物理顺序相同；

**数组**：**逻辑位序和物理位序相差1**



#### 静态分配和动态分配

**静态分配**：数组的大小和空间已经固定，一旦空间占满，再加入新的数据会产生溢出，进而导致程序崩溃；

**动态分配**：一旦数据空间占满，就开辟一块更大的存储空间，用以替换原来的存储空间，从而达到扩充存储数据空间的目的，不需要为线性表一次性的划分内存。



#### 顺序表特点

##### 优点

1. 随机存取
2. 存储密度高，每个结点只存储数据元素

##### 缺点

1. 插入和删除操作需要移动大量元素；
2. 地址连续，分配空间不灵活；



#### 多项式 数据结构

~~~cpp
typedef struct {
  float p; // 系数
  int e;	 // 指数
}Polynomial;

typedef struct {
  Polynomial *elem;		//存储空间地址
  int length;
}
~~~



#### 数据结构 定义

~~~c++
#define MAX_SIZE 100

typedef struct {
  ElemType elem[MAX_SIZE];
  int length;
}SqList;
~~~



#### 初始化

```cpp
bool InitList(SqList &L) {
    L.data = new int[MAX_SIZE];
    if (!L.data) return false;
    L.length = 0;
    return true;
}
```



#### 按值定位

```cpp
int LocalElem(SqList &L, int data) {
    for (int i = 0; i < L.length; ++i)
        if (data == L.data[i]) return i + 1;
    return 0;
}

int LocalElem2(SqList &L, int data) {
    int i = 0;
    while (L.length > 0 && L.data[i] != data) ++i;
    if (i < L.length) return i + 1;
    return 0;
}
```



#### 插入

```cpp
bool ListInsert(SqList &L, int index, int data) {
    if (index < 1 || index > L.length + 1) return false;
    if (L.length == MAX_SIZE) return false;
    for (int i = L.length - 1; i >= index - 1; ++i)
        L.data[i + 1] = L.data[i];
    L.data[index - 1] = data;
    L.length++;
    return true;

}
```



#### 删除

```cpp
bool ListDelete(SqList &L, int index, int &data) {
    if (index < 1 || index > L.length) return false;
    data = L.data[index - 1];
    for (int i = index - 1; i <= L.length - 1; ++i)
        L.data[i] = L.data[i + 1];
    --L.length;
    return true;
}
```



#### 遍历

```cpp
bool TraverseList(SqList &L) {
    if (L.length <= 0) return false;
    for (int i = 0; i < L.length; ++i)
        printf("%d \t", L.data[i]);
    putchar('\n');
}
```



### 链式存储实现 

#### 带头结点的优点

1. 由于第一个数据结点的位置被存放在头结点的指针域中，因此在链表中的**第一个位置上的操作和表中其他位置的操作一致，无需特殊处理**；（不带头结点，插入、删除第1个元素时，需要更改指针L）；
2. 无论链表是否为空，其头指针都指向头结点的非空指针，因此**空表和非空表的处理也得到了了统一**；



#### 链表类别

1. 单链表
2. 双链表
3. 循环链表
4. 静态链表



#### 单链表

> 通过一组任意的存储单元来存储线性表中的数据元素；
>
> 为了建立数据元素之间的线性关系，每个链表结点，除存放元素自身的信息外，还需要存放一个指向其后继的指针；



![image-20220702155255442](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220702155255442.png)



优点：不要求大片连续空间，改变容量方便；

缺点：不可随机存取，要耗费一定空间存放指针；



##### 数据结构 - 定义

~~~cpp
typedef struct LNOde{
  ElemType data;
  struct LNode *next;
}LNode, *LinkList;

// c语言开辟空间方法
struct LNode *p = (struct LNode *) malloc(sizeof(struct LNOde));

LNode *L; // 等价于 LinkLIst L;

~~~



##### 初始化

```cpp
bool InitList(LinkList &L) {
    L = new LNode;
    if (L == NULL) return false;
    L->next = NULL;
    return true;
}
```



##### 插入

###### 前插操作

```cpp
// 指定结点的前插操作 时间复杂度 O(1)
bool InsertPriorNode(LNode *p, int data) {
    if (p == NULL) return false;
    LNode *s = new LNode;

    if (s == NULL) return false; // 内存分配失败；

    s->data = p->data;
    p->data = data;
    s->next = p->next;
    p->next = s;
    return false;
}
```



###### 后插操作

```cpp
// 后插操作：在指定结点之后插入元素 时间复杂度 O(1)
bool InsertNextNode(LNode *p, int data) {
    if (p == NULL) return false;
    LNode *s = new LNode;

    if (s == NULL) return false; // 内存分配失败

    s->data = data;
    s->next = p->next;
    p->next = s;
    return true;
}
```



###### 指定下标插入  - 带头结点

```cpp
// 时间复杂度O(n)
bool ListInsert(LinkList &L, int index, int data) {
    if (index < 1) return false;
    LinkList p;
    int j = 0;
    p = L;
    while (p != NULL && j < index - 1) { // 找到index - 1 之前的结点，在之后插入结点。 （找到要插入元素之前的结点）
        p = p->next;
        j++;
    }

    return InsertNextNode(p, data); // 用后插操作代替

//    if (p == NULL) return false; // index值不合法，超过了链表长度
//
//    LNode *s = new LNode;
//    s->data = data;
//    s->next = p->next;
//    p->next = s;
//    return true;
}
```



指定下标插入  - 不带头结点

```cpp
// 不带头结点 ，插入、删除第1个元素是，需要更改删除指针L；
bool ListInsert2(LinkList &L, int index, int data) {
    if (index < 1) return false;

    // 不带头结点的增加代码
    if (index == 1) {
        LNode *s = new LNode;
        s->data = data;
        s->next = L->next;
        L = s;
        return true;
    }

    LinkList p;
    int j = 1; // 当前p指向的是第几个结点
    p = L;
    while (p != NULL && j < index - 1) { // 找到index - 1 之前的结点，在之后插入结点。 （找到要插入元素之前的结点）
        p = p->next;
        j++;
    }

    if (p == NULL) return false; // i值不合法，超过了链表长度

    LNode *s = new LNode;
    s->data = data;
    s->next = p->next;
    p->next = s;
    return true;
}
```



###### 头插法 - 带头结点

```cpp
// 带头结点 时间复杂度O(n)
bool List_HeadInsert(LinkList &L) {
    int data;
    LinkList s;
    L = new LNode;
    L->next = NULL;
    scanf("%d", &data);
    while (data != 9999) {
        s = new LNode;
        s->data = data;
        s->next = L->next;
        L->next = s;
        scanf("%d", &data);
    }
    return true;
}
```



###### 头插法 -  不带头结

```cpp
// 时间复杂度O(n)
bool List_HeadInsert2(LinkList &L) {
    int data;
    LinkList s;
    scanf("%d", &data);
    while (data != 9999) {
        s = new LNode;
        s->data = data;
        s->next = NULL;
        if (L != NULL){
            s->next = L;
        }
        L = s;
        scanf("%d", &data);
    }
    return true;
}
```



###### 尾插法 - 带头结点

```cpp
//尾插法 - 带头结点 时间复杂度O(n)
void List_TailInsert(LinkList &L) {
    int data;
    L = new LNode;
    LinkList s, r = L;
//    L->next = NULL;
    scanf("%d", &data);
    while (data != 9999) {
        s = new LNode;
        s->data = data;
//        s->next = NULL;
        r->next = s;
        r = s;
        scanf("%d", &data);
    }
    r = NULL;
}
```



##### 删除

###### 删除指定结点p

```cpp
//指定删除结点p 时间复杂度 O(1)， (删除最后一个结点有bug，删除p之后会把空指针异常)
bool DeleteNode(LNode *p) {
    if (p == NULL) return false;
    LinkList q = p->next;
    p->data = q->data;
    p->next = q->next;
    delete q;
    return true;
}
```



######  按位序删除-带头结点 

```cpp
// 时间复杂度O(n)
bool ListDelete(SqList &L, int index, int &data) {
    if (index < 1 || index > L.length) return false;
    data = L.data[index - 1];
    for (int i = index - 1; i <= L.length - 1; ++i)
        L.data[i] = L.data[i + 1];
    --L.length;
    return true;
}
```



##### 遍历

###### 带头结点遍历

```cpp
//带头结点遍历
void TraverseList(LinkList L) {
    LinkList p = L->next;
    while (p != NULL) {
        printf("%d\t", p->data);
        p = p->next;
    }
    putchar('\n');
}
```



###### 不带头结点遍历

```cpp
//不带头结点遍历
void TraverseList2(LinkList L) {
    LinkList p = L;
    while (p) {
        printf("%d\t", p->data);
        p = p->next;
    }
    putchar('\n');
}
```



##### 链表逆置

![image-20220701204913904](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220701204913904.png)

使用头插法链表逆置，由于第一个数据元素本身就在首元结点，因此直接从第二个元素开始前插。

q为移动指针，p前置指针；

步骤：

1. 判断链表是否为空，为空则失败；
2. 前驱指针为p，移动元素指针为q，如果q不为空**（q为空，即链表长度为1或移动完所有元素，则跳出循环）**则进行以下三步：
   1. 将前驱元素p的后继，改为移动指针q的后继；
   2. 将移动指针q的后继，改为首元结点L.next；
   3. 将头指针的后继，改为移动指针q；

```cpp
// 链表逆置 头插法（带头结点）
bool ListReverse(LinkList &L) {
    if (L->next == NULL) return false; // 传入空表则失败
    LinkList  q, p = L->next;
    q = p->next;
    while (q != NULL) { // q == NUll 已到链尾了或链表长度小于2；
        p->next = q->next;
        q->next = L->next;
        L->next = q;
        q = p->next;
    }
    return true;
}
```



##### 按位查找

```cpp
// 按位查找 O(n)
LinkList GetElem(LinkList L, int index) {
    if (index < 0) return NULL;
    LinkList p = L;
    int j = 0;
    while (p != NULL && j < index) {
        p = p->next;
        ++j;
    }
    return p;
}

// 按位查找 2
LinkList GetElem2(LinkList L, int index) {
    int j = 1;
    LinkList p = p->next;
    if (index == 0) return L;
    if (index < 0) return NULL;

    while (p != NULL && j < index) {
        p = p->next;
        ++j;
    }
    return p;
}
```



##### 按值查找

```cpp
//按值查找
LinkList LocateElem(LinkList L, int data) {
    LinkList p = p->next;
    while (p != NULL && data != p->data)
        p = p->next;
    return p;
}
```



##### 链表长度

```cpp
//长度 O(n)
int Length(LinkList L) {
    LinkList p = L;
    int length = 0;
    while (p->next != NULL) {
        p = p->next;
        ++length;
    }
    return length;
}
```



#### 双链表

> 为了克服单链表只能依次顺序向后遍历，引入了双链表，在单链表的基础上增加`prior指针`，表示前驱结点；



##### 单双链表的异同

**相同**

按值查找和按位查找的操作相同

**不同**

插入和删除操作实现，与单链表有着较大的不同，需要同时需改两个方向上的指针。





##### 数据结构 

~~~cpp
typedef struct DNode{
  int data;
  struct DNode *prior, *next;
 
}DNode, *DLinkList;
~~~





##### 插入

###### 双链头插法 

```cpp
bool List_HeadInsert(LinkList &L) {
    int data;
    LinkList s;
    L = new LNode;
    scanf("%d", &data);
    while (data != 9999) {
        s = new LNode;
        s->data = data;
        s->prior = L;
        s->next = L->next;
        if (L->next != NULL) //  链表有数据结点时，才有前驱
            L->next->prior = s;
        L->next = s;
        scanf("%d", &data);
    }
    return true;
}
```



###### 按位插入

当要插入的元素下标<=0时，插入到链表头；

当要插入的元素下标>链表长度时，插入到链表尾；

```cpp
// 在p结点之后插入结点
//双链表 - 插入
bool ListInsert(LinkList &L, int index, int data) {
//    LinkList p = GetElem(L, index);
  
		// 查找结点开始
    LinkList p = L;
    int j = 0;
    while (p->next != NULL && j < index) {
        p = p->next;
        ++j;
    }
   	// 查找结点结束
  
    if (!p) return false;
    LinkList s = new LNode;
    s->data = data;

    s->prior = p;
    s->next = p->next;
    if (p->next != NULL)
        p->next->prior = s;
    p->next = s;
    return true;
}
```



##### 删除

```cpp
//双链表删除
bool ListDelete(LinkList &L, int index) {
    LinkList q, p = L; // p必须为头结点，才能删除第一首元结点
    q = p->next;
    int j = 1;
    while (q != NULL && j < index) {
        p = p->next;
        q = q->next;
        ++j;
    }
    if (q == NULL) return false;

    p->next = q->next;
    if (q->next != NULL) // 如果q为最后一个元素，则q->next为空
        q->next->prior = p;
    delete q;
    return true;
}
```



##### 按位查找

```cpp
LinkList GetElem(LinkList &L, int index) {
    if (L == NULL) return NULL;
    if (L->next == NULL) return L;
    int j = 0; 
    LinkList p = L;
    while (p->next != NULL && j < index) {
        p = p->next;
        ++j;
    }
    return p;
}
```



#### 循环列表

循环单链表

与单链表的区别

1. 尾结点的next不是NULL而是头结点；
2. 循环单链表判空条件 ：**不是头结点的指针是否为空，而是是否等于头指针**。



##### 循环双链表

与单链表的区别

1. 尾结点的next不是NULL而是头结点；
2. 头结点的prior不是NULL而是尾结点；
3. 循环双链表判空条件：**头结点的prior和next都等于头结点**；



##### 静态列表

借助数组来描述线性表的链式存储结构，结点也有数据域和指针域。指针是结点的相对位置，又称游标。静态链表要预先分配一块连续的内存空间。

**插入和删除不需要移动元素，只需要修改指针即可。**



##### 数据结构

~~~cpp
#define MAX_SIZE 50
typedef struct{
  ElemType data;
  int next
}SLinkList[MAX_SIZE];
~~~

在一些不支持指针的高级语言（Basic)中，是一种巧妙的设计。



### 顺序表和链表的比较

| 比较方向             | 顺序表                                                       | 链表                                                         |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 存取方式             | 随机存取                                                     | 顺序存取                                                     |
| 逻辑和物理结构       | 物理上相邻，逻辑上也相邻                                     | 物理上相邻，逻辑上不一定相邻                                 |
| 查找、插入和删除操作 | 按值查找时间复杂度O(n)，按序查找O(1)；<br />插入、删除需要移动大量元素，效率低。 | 按值查找和按序查找都是时间复杂度O(n)<br />修改指针即可       |
| 空间分配             | 需预先分配固定空间，不够灵活。分配过大，内存浪费，分配过小，内存溢出，但存储密度高。 | 动态分配内存空间，操作灵活。但有额外的指针开销，存储密度低。 |



### 如何选取存储结构？

1. 基于存储考虑
   1. 难以估计的存储规模时，不易采用顺序表；
   2. 追求存取密度不易链表；
2. 基于运算考虑
   1. 频繁修改，链表；
   2. 追去按序查找，顺序表；
3. 基于环境考虑



### 习题

递归算法，删除不带头结点的单链表中所有值为x的结点

~~~cpp
void De(LinkList &L, EeleType x){
  if(L != NULL){
    De(L->next, x);
    if(L.elem == x){
      p = L;
      L = L.next;
      free(p);
    }
  }
}
~~~



『2009统考真题』已知一个带有表头结点的单链表，假设只给出该链表的头指针，在不改变链表的前提下，设计一个尽可能高效的算法，查找链表中倒数第k个位置上的结点（k为正整数）。若查找成功，算法输出该结点的data域的值，并返回1；否则，只返回0。

要求：

1. 描述算法的基本设计思路；
2. 描述算法的详细实现步骤；
3. 根据设计思想和实现步骤，采用程序设计语言描述算法（使用C、C++或Java语言实现），关键之处给出简要注释。



1. 设计思路

   > 设计尽可能搞笑的算法，通过一次遍历，找到倒数第k位的结点。
   >
   > 1. 定义两个指针p和q，初始是p和q都指向首元结点；
   > 2. p开始沿链表移动，当p移动到离q第k个结点之后，q也开始移动；
   > 3. 当p移动到链尾，q则指向倒数第k个结点。

2. 详细实现步骤

   1. 判断链表是否为空，为空则失败；
   2. 定义count=0，p和q指向首元结点；
   3. 若p为空，则跳出循环；
   4. 当p不为空，判断k==count不等则count++，相等则p=p.next；
   5. p=p.next，转到步骤3；
   6. 当k!=count，则说明k值操作了链表长度，返回0，当k==count，则打印倒数第k个元素的数据域，返回1。

3. 具体实现

   ~~~cpp
   bool LocalReverseElem(LinkList &L, int k) {
       if (L->next == NULL) return false;
       LinkList q, p = L->next;
       q = p;
       int count = 0;
       while (p != NULL) {
           if (count == k) q = q->next;
           else ++count;
           p = p->next;
       }
       if (k != count) return false;
       printf("当前-%d位数据为：%d", k, q->data);
       return true;
   }
   ~~~

   



## 第三章 栈和队列

![image-20220704090220853](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220704090220853.png)

### 栈

栈：是只允许一端进行插入或删除操作的线性表，即后进先出；

栈顶：允许进行插入删除的一端；

栈底：固定的，不允许进行插入和删除的另一端。



#### 栈的基本操作

1. InitStack(&S);
2. StackEmpty(S);
3. Push(&S,x);
4. Pop(&S,&x);
5. GetTop(&S,&x);
6. DestoryStack(&S);



#### 顺序栈

> 采用顺序存储的栈称为顺序栈，利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针`top`指示当前的位置。



##### 顺序栈的弊端

由于顺序栈和顺序表一样，收到最大空间的限制，虽然可以在“满员“是重新分配空间扩容，但工作量较大，应尽量避免。



##### 数据结构 - 定义

~~~cpp
#define MAX_SIZE 50
// 第一种 数组方式
typedef struct {
  ElemType data[MAX_SIZE];
  int top;
}SqStack;

//相关条件
//栈空条件：S.top=-1；
//栈满条件：S.top==Maxsize-1;
//栈长：S.top+1；

// 第二种 指针方式
typedef struct{
  SElemType *base;
  SElemType *top;
  int statckSize;
}SqStack;
//相关条件
//栈空条件：S.top == S.base；
//栈满条件：S.top - S.base == S.stackSize;
//栈长：statckSize；
~~~



##### 初始化

```cpp
// 第一种 
void InitStack(SqStack &S) {
    S.top = -1;
}

// 第二种
bool InitStack(SqStack &S) {
    S.base = new int[MAX_SIZE];
    S.top = S.base;
    S.stackSize = MAX_SIZE;
    return true;
}
```



##### 栈判空

```cpp
// 第一种
bool EmptyStack(SqStack &S) {
    if (S.top == -1)
        return true;
    return false;
}

// 第二种
bool EmptyStack(SqStack &S) {
    if (S.top == S.base)
        return true;
    return false;
}
```



##### 进栈

```cpp
// 第一种
bool Push(SqStack &S, int x) {
    if (S.top + 1 == MAX_SIZE) return false;
    S.data[++(S.top)] = x; // 先加后压
    return true;
}

// 第二种
bool Push(SqStack &S, int x) {
    if (S.top - S.base == S.stackSize) return false;
    *S.top++ = x; // 先压后加
    return true;
}
```



##### 出栈

```cpp
// 第一种
bool Pop(SqStack &S, int &x) {
    if (S.top == -1) return false;
    x = S.data[S.top--]; // 先弹后减
    return true;
}

// 第二种
bool Pop(SqStack &S, int &x) {
    if (S.top == S.base) return false;
    x = *(--S.top); // 先减后弹
    return true;
}
```



##### 读取栈顶元素

```cpp
// 第一种
bool GetTop(SqStack &S, int &x) {
    if (S.top == -1) return false;
    x = S.data[S.top];
    return true;
}

// 第二种
bool GetTop(SqStack &S, int &x) {
    if (S.top == S.base) return false;
    x = *(S.top - 1);
    return true;
}

int GetTop(SqStack &S) {
    if (S.top != S.base)
        return *(S.top - 1);
}
```



#### 链栈

> 采用链式存储的栈称为链栈，通常采用单链表实现，**并规定链表头作为栈顶，且为了方便操作无头结点**。
>
> 栈顶指针一直指向链表头



##### 链栈的优点

1. 便于多个栈共享存储空间和提高其效率；
2. 不存在栈满上溢的情况。



##### 数据结构 - 定义

~~~cpp
typedef struct LinkNode{
  ElemType data;
  struct LinkNode *next;
} StackNode, *ListStack;
~~~



##### 初始化

```cpp
bool InitStack(LinkStack &S) {
    S = NULL;
    return true;
}
```



##### 栈判空

```cpp
bool EmptyStack(LinkStack &S) {
    if (S == NULL)
        return true;
    return false;
}
```



##### 进栈

```cpp
bool Push(LinkStack &S, int data) {
    LinkStack p = new StackNode;
    p->data = data;
    p->next = S;
    S = p;
    return true;
}
```



##### 出栈

```cpp
bool Pop(LinkStack &S, int &data) {
    if (S == NULL) return false;
    LinkStack p = S;
    S = S->next;
    data = p->data;
    delete p;
    return true;
}
```



##### 读取栈顶元素

```cpp
int GetTop(LinkStack &S) {
    if (S != NULL)
        return S->data;
}
```



#### 共享栈

利用栈底位置相对不变的特性，让两个顺序栈共享一个一维数组空间，将两个栈的栈底分贝设置在共享空间的两端，两个栈顶向共享空间的中间延伸；



###### 相关条件

栈空：top0=-1、top=MAX_SIZE；

栈满：top1-top0=1；

出栈：0号栈先加再压，1号栈先减后压；

出栈：0号栈先弹再减，1号栈先弹后加；



##### 顺序栈的优点

能有效地利用存储空间，两个栈空间相互调节，只有整个空间栈满是才发生上溢，其存取数据的时间复杂度均为O(1)，所有对存取效率没什么影响；



##### 共享栈相关操作

```cpp
#include <iostream>

using namespace std;
#define MAX_SIZE 5
typedef struct {
    int data[MAX_SIZE];
    int top0; // 1号栈顶指针
    int top1;	// 2号栈顶指针
} SqStack;

void InitStack(SqStack &S) {
    S.top0 = -1;
    S.top1 = MAX_SIZE;
}

bool EmptyStack(SqStack &S, int flag = 0) {
    if (S.top0 == -1 && flag == 0)
        return true;
    if (S.top1 == MAX_SIZE && flag != 0)
        return true;
    return false;
}

// 进栈 flag=0代表1号栈，flag=1代表2号栈
bool Push(SqStack &S, int x, int flag = 0) {
    if (S.top1 - S.top0 == 0) return false;

    if (flag == 0)
        S.data[++(S.top0)] = x; // 先加后压
    else {
        S.data[--(S.top1)] = x;
    }
    return true;
}

// 出栈
bool Pop(SqStack &S, int &x, int flag = 0) {

    if (flag == 0) {
        if (S.top0 == -1) return false;
        x = S.data[S.top0--]; // 先弹后减
    } else {
        if (S.top1 == MAX_SIZE) return false;
        x = S.data[S.top1++]; // 先弹后加
    }
    return true;
}

bool GetTop(SqStack &S, int &x, int flag = 0) {
    if (flag == 0) {
        if (S.top0 == -1) return false;
        x = S.data[S.top0]; // 先弹后减
    } else {
        if (S.top1 == MAX_SIZE) return false;
        x = S.data[S.top1]; // 先弹后加
    }
    return true;
}

int main() {
    SqStack S;
    InitStack(S);
    for (int i = 1; i <= 3; ++i)
        Push(S, i);
    for (int i = 5; i > 3; --i)
        Push(S, i, 1);
    int d1, d2;
    GetTop(S, d1);
    GetTop(S, d2, 1);
    printf("d1 = %d, d2 = %d\n", d1, d2);
    Pop(S, d1);
    Pop(S, d2, 1);
    printf("d1 = %d, d2 = %d\n", d1, d2);
    Pop(S, d1);
    Pop(S, d2, 1);
    printf("d1 = %d, d2 = %d\n", d1, d2);
    Pop(S, d1);
    Pop(S, d2, 1);
    printf("d1 = %d, d2 = %d\n", d1, d2);
    Pop(S, d1);
    Pop(S, d2, 1);
    printf("d1 = %d, d2 = %d\n", d1, d2);
    EmptyStack(S);
    EmptyStack(S, 1);
    return 0;
}
```



#### 栈与递归

> 在函数、过程或数据结构定义的内部又直接或间接出现定义本身的应用，称之为递归。



##### 递归的优缺点

优点：

1. 结构清晰、形式简洁；



缺点：

1. 占用内存空间较多，运行效率较低；（递归程序执行时，需要系统提供隐式的工作栈来保存调用过程中的参数、局部变量和返回地址）



##### 定义是递归的

阶乘、Fabonacci

分治法：把复杂 的问题分解成几个相对简单且解法相同的或类似的子问题来求解，称之为递归求解，即分治法。

分治法满足的三个条件：

1. 能将一个问题转变成一个新问题，而新问题与原问题的解法相同或类同，不同的仅是处理的对象，并且这些处理对象更小且变化有规律；
2. 可以通过上述转换简化问题；
3. 必须有一个明确的递归出口，或递归边界。



##### 数据结构是递归的

数据结构本身具有递归的特性，如链表的数据结构中next。



##### 问题的解法是递归的

问题本身没有明显的递归结构，但是递归求解比迭代求解更简单。如hanoi塔、八皇后、迷宫等问题；



### 队列

> 队列是一种先进先出（First In First Out, FIFO）的受限线性表，它只允许在队尾插入，队头删除。插入、删除也称入队、出队。
>
> 最典型的应用就是操作系统的作业排队
>
> 

#### 基本操作

1. InitQueue(&Q);
2. QueueEmpty(&Q);
3. EnQueue(&Q, x);
4. DeQueue(&Q, &x);
5. GetHead(&Q);



#### 循环队列

##### 假溢出

> 因数组越界而导致程序的非法操作错误，此时队列实际上空间未被占满；是由于“队尾入队，队头出队”这种受限制操作造成的。
>
> ![image-20220706095225808](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220706095225808.png)
>
> 为了解决“假溢出”我将顺序队列变为一个环状的空间，称之为**循环队列**。

循环列表带来的问题

不能以头、尾指针的是否相同来盘被队“空”还是“满”，因为无论”队空“还是“队满”头尾指针都指向同一空间。

解决方案：

1. 少用一个元素空间：
   1. 队空：Q.front = Q.rear；
   2. 队满：(Q.rear + 1) % MAX_SIZE == Q.front
2. 设置标志位来区别队列是“空”还“满”



##### 数据结构 - 定义

```cpp
typedef struct {
    int *base; //存储空间基地址
    int front; // 头指针
    int rear;  // 尾指针
} SqQueue;
```



##### 初始化

```cpp
bool InitQueue(SqQueue &Q) {
    Q.base = new int[MAX_SIZE];
    if (!Q.base) return false; // 存储分配失败
    Q.front = Q.rear = 0;
    return true;
}
```



##### 队列长度

1. 对于非循环队列，尾指针和头指针的差值便是队列长度；
2. 对于循环队列，差值可能为负数，所以需要将差值加上MAX_SIZE，在与MAX_SIZE取模。

```cpp
int Length(SqQueue &Q) {
    return (Q.rear - Q.front + MAX_SIZE) % MAX_SIZE; 后减前
}
```



##### 进队

```cpp
bool EnQueue(SqQueue &Q, int x) {
    if ((Q.rear + 1) % MAX_SIZE == Q.front) return false;
    Q.base[Q.rear] = x;
    Q.rear = (Q.rear + 1) % MAX_SIZE;
    return true;
}
```



##### 出队

```cpp
bool DeQueue(SqQueue &Q, int &x) {
    if (Q.rear == Q.front) return false;
    x = Q.base[Q.front];
    Q.front = (Q.front + 1) % MAX_SIZE;
    return true;
}
```



##### 队头元素

```cpp
int GetHead(SqQueue &Q) {
    if (Q.front != Q.rear)
        return Q.base[Q.front];
    return -9999;
}
```



#### 链式队列

若用户无法预估所用队列的最大长度，链队是一个好的选择。链队通常用单链表表示。

为了操作方便起见，给链队添加一个头结点，并令头指针始终指向头结点。



##### 数据结构 - 定义

```cpp
// 链节点
typedef struct QNode {
    int data;
    struct QNode *next;
} QNode, *QueuePtr;

// 链队
typedef struct {
    QueuePtr front;
    QueuePtr rear;
} LinkQueue;
```



##### 初始化

```cpp
bool InitQueue(LinkQueue &Q) {
    Q.front = Q.rear = new QNode; // 作为头结点， 队头和队尾都指向头结点
    Q.front->next = NULL; //头结点的指针域置空
    return true;
}
```



##### 进队

进队操作队尾指针会变化指向，而队头指针始终指向头结点，只会一直更换首元结点的指向

```cpp
bool EnQueue(LinkQueue &Q, int x) {
    QueuePtr p = new QNode;
    p->next = NULL;
    p->data = x;
    Q.rear->next = p;
    Q.rear = p;
    return true;
}
```



##### 出队

注意：在链队出队操作时要考虑当前队列中最后元素被删后，队列尾指针也会丢失，因此需要对尾指针重新赋值指向头结点。

```cpp
bool DeQueue(LinkQueue &Q, int &x) {
    if (Q.front == Q.rear) return false;
    QueuePtr p = Q.front->next;
    x = p->data;
    Q.front->next = p->next;
    if (Q.rear == p) Q.rear = Q.front; // 最后一个元素被删，队尾指针指向头结点
    delete p;
    return true;
}
```



##### 队头元素

```cpp
int GetHead(LinkQueue &Q) {
    if (Q.front == Q.rear) return -1;
    return Q.front->next->data;
}
```



#### 双端队列



### 应用场景

#### 栈

1. 递归：
2. 运算符优先法；
3. 进制转换；
4. 括号匹配的检验



#### 队列

1. 协调进程调度；
2. 解决OS中主机与外设之间速度不匹配或多个用户引起的资源竞争；
3. 模拟排队场景；



### 栈和队列的异同

#### 相同点

1. 逻辑结构，都和线性表一致，数据元素之间存在一对一的关系；
2. 存储结构，都可以采用顺序和链式存储；

#### 不同点

1. 运算规则，栈插入删除在栈顶完成，后进先出，而队列队尾插入、队头删除，先进先出。



### 案例实现

#### 数制的转换

1. 案例分析

   当将一个十进制整数N转换为八进制数时，在计算过程中，把N与8求余得到的八进制的各位依次进栈，计算完毕后将栈中的八进制数依次出栈输出，输出结果就是带求得的八进制数。

2. 算法步骤

   1. 初始化一个空栈；
   2. 当十进制数N非零时，循环执行一下操作：
      1. 把N与8秋月得到的八进制数压入栈S；
      2. N更新为N与8的商；
   3. 当栈S非空是，循环一下操作：
      1. 弹出栈顶元素data；
      2. 输入data

3. 算法描述

   ```cpp
   //进制转换 10 to 8 
   void conversion(LinkStack &S, int n) {
       InitStack(S);
       while (n) {
           Push(S, n % 8);
           n /= 8;
       }
   
       int data;
       while (!EmptyStack(S)) {
           Pop(S, data);
           cout << data;
       }
   
   }
   
   ```



#### 括号匹配

1. 案例分析

   检验算法借助一个栈，每当读入一个左括号，则直接入栈，等待相匹配的同类有括号，若与当前栈顶的左括号类型相同，则二者匹配，将栈顶的左括号出栈，直到表达式扫描完毕。

   在处理过程中，还要考虑括号不匹配出错的情况。例如：

   1. 当出现`(()[]))`时，由于前面入栈的左括号均已和后面出现的有括号匹配，栈已空，一次最后扫描的有括号不能得到匹配；
   2. `[([])]`这种错误，当表达式扫描结束时，栈中还有一个左括号没有匹配；
   3. 出现`(()]`这种错误显然是栈顶的左括号和最后的右括号不匹配。

2. 算法步骤

   1. 初始化一个空栈；
   2. 设置以标记性变量flag，用来标记匹配结果以控制循环及返回结果，1表示正确匹配，0表示错误匹配，flag初值为1；
   3. 扫描喵大师，一次读入字符ch，若表达式没有扫描完毕且flag非零，则循环执行一下操作：
      1. 若ch是左括号`[`或`(`，则将其压入栈；
      2. 若ch是左括号`)`，则根据当前栈顶元素的值分情况考虑；若栈非空且栈顶元素是`(`则正确匹配，否则错误匹配，flag置为0；
      3. 若ch左括号`]`，则根据当前栈顶元素的值分情况考虑；若栈非空且栈顶元素是`[`则正确匹配，否则错误匹配，flag置为0；
   4. 退出循环后，如果栈空且flag值为1,则匹配成功，返回true，否则返回false

3. 算法描述 时间复杂度 O(n)

   ```cpp
   //括号匹配的检验
   bool Matching() {
       LinkStack S;
       InitStack(S);
   
       int flag = 1; // 标记匹配结果以控制循环及返回结果
       char ch;
       cin >> ch;
       int x;
       while (ch != '#' && flag) {
           switch (ch) {
               case '(':
               case '[':
                   Push(S, ch);
                   break;
               case ')':
                   if (!EmptyStack(S) && GetTop(S) == '(')
                       Pop(S, x);
                   else flag = 0;
                   break;
               case ']':
                   if (!EmptyStack(S) && GetTop(S) == '[')
                       Pop(S, x);
                   else flag = 0;
                   break;
           }
           cin >> ch;
       }
       if (EmptyStack(S) && flag) return true;
       return false;
   }
   ```





### 算法设计



#### 进制转换  - 栈

```cpp
//进制转换 10 to 8
void conversion(LinkStack &S, int n) {
    InitStack(S);
    while (n) {
        Push(S, n % 8);
        n /= 8;
    }

    int data;
    while (!EmptyStack(S)) {
        Pop(S, data);
        cout << data;
    }

}
```



#### 括号匹配的检验 - 栈

```cpp
//括号匹配的检验
bool Matching() {
    LinkStack S;
    InitStack(S);

    int flag = 1; // 标记匹配结果以控制循环及返回结果
    char ch;
    cin >> ch;
    int x;
    while (ch != '#' && flag) {
        switch (ch) {
            case '(':
            case '[':
                Push(S, ch);
                break;
            case ')':
                if (!EmptyStack(S) && GetTop(S) == '(')
                    Pop(S, x);
                else flag = 0;
                break;
            case ']':
                if (!EmptyStack(S) && GetTop(S) == '[')
                    Pop(S, x);
                else flag = 0;
                break;
        }
        cin >> ch;
    }
    if (EmptyStack(S) && flag) return true;
    return false;
}
```



#### 括号匹配 - 栈

```cpp
char operators[][2] = {
        {')', -1},
        {'+', '-'},
        {'*', '/'},
        {'(', -1},
};

//比较字符优先级
char Precede(char top, char x) {
    int top_loc, x_loc;
    if (top == x) return '>';
    if (top == '(' && x == ')') return '=';
    for (int i = 0; i < 4; ++i) {
        for (int j = 0; j < 2; ++j) {
            if (top == operators[i][j]) top_loc = i;
            if (x == operators[i][j]) x_loc = i;
        }
    }

    if (top_loc < x_loc || top == '#' || top == '(') return '<';
    return '>';
}

// 四则运算
int operate(int x, int op, int y) {
    x -= 48;
    y -= 48;
    switch (op) {
        case '+':
            return x + y + 48;
        case '-':
            return x - y + 48;
        case '*':
            return x * y + 48;
        case '/':
            return x / y + 48;
        default:
            return -1;
    }
}

//表达式匹配
char EvaluateExpression() {
    LinkStack OPND, OPTR;
    InitStack(OPND);
    InitStack(OPTR);
    Push(OPTR, '#');
    char ch;
    int op;
    int x, y;
    cin >> ch;
    while (ch != '#' || GetTop(OPTR) != '#') {
        if ('0' < ch && ch < '9') {
            Push(OPND, ch);
            cin >> ch;
        } else {
            switch (Precede(GetTop(OPTR), ch)) {
                case '<':
                    Push(OPTR, ch);
                    cin >> ch;
                    break;
                case '>':
                    Pop(OPTR, op);
                    Pop(OPND, y);
                    Pop(OPND, x);
                    Push(OPND, operate(x, op, y));
                    break;
                case '=':
                    Pop(OPTR, x);
                    cin >> ch;
                    break;
            }

        }

    }
    return GetTop(OPND);
}
```



#### 判断回文数

```cpp
bool isPalindrome(string &str) {
    LinkStack S;
    int data;
    char ch;
    InitStack(S);
//    // 普通方法
//    for (int i = 0, j = str.length() - 1; i<j; ++i,--j)
//        if (str[i] != str[j]) return false;
    // 栈
    for (int i = 0; i < str.length() / 2 + str.length() % 2; ++i) {
        ch = str[i];
        Push(S, ch);
    }
    for (int i = str.length() / 2; Pop(S, data); ++i) {
        printf("%c, %c\n", data, str[i]);
        if (data != str[i]) return false;
    }

    return true;
}
```





双栈

```cpp
/**
* @Time ：  2022/7/9 10:51
* @Auth ： Reddy · Fan
* @File ：01_double_stack.cpp
* @Description : 
*/
#include <iostream>

using namespace std;
#define   MAX_SIZE 6

typedef union {
    char ch;
    int num;
} SElemType;

typedef struct {
    int top[2], bot[2];
    SElemType *V;
    int m;
} DStack;

bool InitDoubleStack(DStack &S) {
    S.V = new SElemType[MAX_SIZE];
    if (S.V == NULL) return false;
    S.m = MAX_SIZE;
    S.top[0] = S.bot[0] = -1;
    S.top[1] = S.bot[1] = S.m;
    return true;
}

bool EmptyStack(DStack &S, int flag = 0) {
    if (S.top[flag] == S.bot[flag])return true;
    return false;
}

bool FullStack(DStack &S) {
    if (S.top[1] == S.top[0] == 1)return true;
    return false;
}

//flag 0代表编号为0栈，1代表1栈
bool Push(DStack &S, SElemType ele, int flag = 0) {
    if (FullStack(S)) return false;
    if (flag) {
        S.V[--S.top[1]] = ele;
    } else {
        S.V[++S.top[0]] = ele;
    }
    return true;

}


bool Pop(DStack &S, SElemType &ele, int flag = 0) {
    if (EmptyStack(S, flag)) return false;
    if (flag) {
        ele = S.V[S.top[1]++];
    } else {
        ele = S.V[S.top[0]--];
    }
    return true;

}

int main() {
    DStack S;
    InitDoubleStack(S);
    cout << "双栈是否为空：" << (EmptyStack(S) && EmptyStack(S, 1)) << endl;
    cout << "双栈是否已满：" << FullStack(S) << endl;
    SElemType e;
    for (int i = 1; i <= 3; ++i) {
        SElemType e;
        e.num = i;
        Push(S, e);
        Push(S, e, 1);
    }

    for (int i = 0; i <= 5; ++i)printf("%d \t ", S.V[i]);
    printf("\n");

    Pop(S, e);
    printf("%d \n", e);
    Pop(S, e, 1);
    printf("%d \n", e);
    return 0;
}
```



## 第四章 串、数组和广义表

### 串

> 为什么引入串？
>
> 在计算机的数据处理中大多都是非数值对象，如音视频、动画、字符串等，而非数值处理的对象大部分是字符串数据。因此，我引入串对字符串这类数据类型进行相应的处理操作。
>
> 串：是由零个或多个字符组成的有限序列。
>
> 串的逻辑结构和线性表显示，区别仅在于串的数据对象约束为字符集；



#### 名词解释

1. 空串：零个字符的串；
2. 子串：串中任意个连续的字符组成的子序列；
3. 主串：包含子串的串；
4. 空格串：有一个或多个空格组成的串；`" "`



#### 应用场景

1. 文字编辑；
2. 信息检索；
3. 语言编译；
4. 网络入侵检测；
5. 计算机病毒特征码匹配；
6. DNA序列匹配；



#### 存储结构

> 串也有两种基本的存储结构：顺序存储和链式存储，考虑到存取效率和方便性，多采用顺序存储。



##### 顺序存储 - 数据结构

定义方式是静态的，在编译时刻就确定了串空间的大小。

~~~cpp
#define MAX_LEN 50
typedef struct{
  char ch[MAX_LEN+1];
  int length;
}SString;
~~~



##### 堆顺序存储 - 数据结构

动态分配和释放数组空间，使用”堆“——自由存储区，为每个新产生的串动态的分配一块实际串长所需的存储空间。

~~~cpp
typdef struct{
  char *ch; // 非空串按串长分配存储区，否则ch为NULL
  int length;
}HString;
~~~



##### 链式存储 - 数据结构

便于插入和删除操作；

结点大小问题：每个结点存放一个字符，也可存放多个字符。在每个结点存放多个字符时，串长不一定是结点大小的整数倍，通常用`#`补齐未被占满的空间。

为了便于串的操作，在存储串值时，出头指针外，还可附设一个尾指针指示链表中的最后一个结点，并给出当前串的长度，如此定义的串存储结构被称为块链结构。

~~~cpp
#define CHUNKSIZE 80
typedef struct Chunk{
  char ch[CHUNKSIZE];
  struct Chunk *next;
}Chunk;

typedef struct{
  Chunk *head, *tail;
  int length;
}LString;
~~~



#### 串的模式匹配

> 模式匹配：对子串的定位运算

##### 应用场景

1. 搜索引擎；
2. 拼写检查；
3. 语言翻译；
4. 数据压缩；



##### BF算法

BF算法：主串与子串按序比较，当主串与子串比较的位置不一致时，主串回到`当前比较的起始位置+1`的位置，子串回到起始位置继续比较。直到比较成功或主串当前匹配位置超过起始位置为止。

~~~cpp
void BF({SString S, SString T, int pos = 1){
  int i = pos, j = 1;
  while(S.length >= i && j <= T.length){
    if(S.ch[i] == T.ch[j]){
      ++i;
      ++j;
    }else{
      i = i - j - 2;
      j = 1;
    }
  }
  if(j > T.length) return i - T.length;
  return 0;
}
~~~



##### KMP算法

###### 核心思想

> 对BF算法的改进，在每次匹配不等时，不回溯`i`指针，而利用已经得到的`部分匹配`结果，将模式串`向右滑动`到尽可能远的一段距离后，继续进行比较。

~~~cpp
void KMP({SString S, SString T, int pos = 1){
  int i = pos, j = 1;
  while(S.length >= i && j <= T.length){
    if(S.ch[i] == T.ch[j]){
      ++i;
      ++j;
    }else{
      j = next[j];
    }
  }
  if(j > T.length) return i - T.length;
  return 0;
}
~~~



###### next数组算法

~~~cpp
void get_next(SString T, int next[]){
  int i = 1, j = 0;
  next[1] = 0;
  while(i < T.length){
    if(j == 0 || T.ch[i] == T.ch[j]){
      ++i;
      ++j;
      next[i] = j;
    }else
      j = next[j];
  }
}
~~~



###### get_nextval

~~~cpp
void get_nextval(SString T, int nextval[]){
 int i = 1, j = 0;
  nextval[1] = 0;
  while(i < T.length){
    if(j == 0 || T.ch[i] == T.ch[j]){
      ++i;
      ++j;
      if(T.ch[i] != T.ch[j])nextval[i] = j;
      else nextval[i] = nextval[j];
    }else
      j = nextval[j];
  }
}
~~~



###### BF和KMP优缺点

BF实现简单、但存在回溯，效率低，时间复杂度O(m*n)；

KMP是对BF算法的改进，消除回溯，提高效率，时间复杂度O(m+n)；



### 数组

有类型相同的数据元素构成的有序集合，每个元素称为数组元素。

A[0…m-1, 0…n-1]下标从0开始，共有m行n列
$$
LOC(i,j)=LOC(0,0)+(n*i+j)L
$$


#### 特殊矩阵的压缩存储

**压缩存储**：是指为多个值相同的元只分配一个存储空间，对零元不分配空间。

**特殊矩阵**：值相同的元素或零元素在矩阵中的分布有一定规律的矩阵。

1. 对称矩阵；
2. 三角矩阵；
3. 对角矩阵；



**为什么要压缩矩阵**？

由于矩阵中有很多相同的元素或零元素，有时为了节省空间，可以对这类矩阵进行压缩存储。



### 广义表

广义表又称列表，是对线性表的推广，广泛的应用于人工智能和大数据等领域。

#### 广义表的重要结论

1. 广义表是一个多次次的结构，广义表的元素可以是子表，而子表的元素还可以是子表；

2. 广义表可以为其他广义表所共享，可以通过子表的名称来引用；

   ~~~python
   # python
   li2 = [1, 2, 3]
   l2 = [1, li2, 3]
   print(l2)  # [1, [1, 2, 3], 3]
   ~~~

3. 广义表是一个可递归的表。



#### 广义表的存储结构

广义表中的数据元素可以有不同的结构，因此难以用顺序存储结构表示，通常采用链式存储结构。

常用的链式存储结构：

1. 头尾链表
2. 扩展线性表



#### 头尾链表数据结构 -- 定义

~~~cpp
typedef enum{ATOM, LIST} ElemTag; // ATOM = 0 - 原子, LIST = 1 - 子表
typedef struct GLNode{
  ElemType tag;
  union{
    AtomType atom;
    struct {struct GLNode *hp, *tp;} ptr;
  }
}
~~~



## 第五章 树和二叉树

### 应用场景

1. 文件目录的组织结构；
2. 数据库系统中信息的重要组织形式，BTree、B+Tree;



### 树的定义及术语

**树的结构定义是一个递归的定义，即在树的定义中又用到树的定义。**

树是n(n≥0)个结点的有限集，有且仅有一个根节点；

1. 空树：n=0;
2. 子树：除根节点以外的其余结点可分为m(m>0)个互不相交的有限集合；
3. 结点的度：结点拥有子树的数；
4. 树的度：树内各结点度的最大值；
5. 叶子/终端结点：度为0的结点；
6. 非终端结点/分支结点：度不为0的结点；
7. 树的深度：树中结点的最大层次称为树的深度或高度；
8. 有序树和无序树：次序不能互换的数称为有序树，否则，就是无序树；
9. 森林：m(m≥0)可互不相交的数的集合。子树的集合即为森林；



### 二叉树的定义

除了根结点以外的其余结点分为两个无不相交的子集，分别称为左子树和右子树，且左右子树本身都是二叉树；

1. 二叉树每个结点至多只有两颗子树；
2. 二叉树的子树有左右之分，其次序不能任意颠倒；



### 案例引入

#### 数据压缩

大数据时代的到来，如何采用有效的数据压缩技术，来节省数据文件的存储空间和网络传输时间越来越引起人们的重视。



数据压缩中的编码：将数据文件转为二进制字符0、1组成的二进制串；

编码方式：

1. 等长编码 ：编码简单，但空间利用有待提高。
2. 不等长编码：通过字符出现的频率，决定字符的编码的长度，出现频率高的编码尽可能短，频率低的编码稍长一点，可获得更好的空间效率。

**不等长编码的必要条件：任何一个字符的编码都不是另一个字符编码的前缀。**



#### 利用二叉树求解表达式的值





### 二叉树的重要特性

1. 在二叉树的第i层上至多有2<sup>i-1</sup>个结点（i≥1）；

2. 深度为k的二叉树至多有2<sup>k</sup>-1个结点（k≥1）；

3. 对任何一棵二叉树T，如果其终端结点数为n<sub>0</sub>，度为2的结点树n<sub>2</sub>，则n<sub>0</sub>=n<sub>2</sub>+1；

   1. 满二叉树：深度为k且含有2<sup>k</sup>-1个结点的二叉树。每一层的节点数都是最大节点数。

   2. 完全二叉树：深度为k，有n个结点的二叉树，当且仅当每一个结点都与深度k的满二叉树中的编号从1至n的结点一一对应。

      * 叶子结点只可能出现在层次最大的两层之上；
      * 对任意结点，左分支的最大层次等于或比其右分支最大层次多一层；

      

4. 具有n个结点的完全二叉树的深度为(log<sub>2</sub>n)+1

   ![image-20220716154713964](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220716154713964.png)

5. 对一棵有n个结点的完全二叉树的结点按层序编号，有

   1. 若i=1，则结点i为根结点，无双亲；若i>1，则其双亲是i/2；
   2. 若2i>n，则结点i无左孩子，否则i结点左孩子为2i；
   3. 若2i+1>n，则结点i无右孩子，否则i结点右孩子2i+1；



### 二叉树的存储结构

#### 顺序存储

用一组连续的存储空间来存储数据元素，为了能够在存储结构中反映出结点之间的逻辑关系，必须将二叉树中的结点依照一定的规律安排这组单元中。

~~~cpp
#define MAX_SIZE 100
typedef TElemType SqBiTree[MAX_SIZE];
SqBiTree bt;
~~~

**顺序存储结构仅适用完全二叉树**，在深度为k且只有k个结点的单支树中也要分配长度为2<sup>k</sup>-1的一维数组，造成了存储空间的极大浪费，因此对应一般二叉树采用链式存储结构。



#### 链式存储

设计不同的结点结构可构成不同形式的链式存储结构，如二叉链表、三叉链表；

在含有n个结点的二叉链表中有n+1个空链域，可以由此构建**线索链表**。

~~~cpp
typdef struct BiTNode{
  TElemType data;
  struct BiTNode *lchild, *rchild;
}BiTNode, *BiTree;
~~~



### 遍历二叉树和线索二叉树

线索二叉树是在第一次遍历时将结点的前驱、后继信息存储下来，便于再次遍历二叉树。

线索二叉树增加了两个指针域来判别是否是结点前后驱，这降低了结构的存储密度。

**n个结点的二叉链表中有n+1个空链域。**

#### 遍历二叉树

是指按某条搜索路径寻访树中的每个结点，是的每个结点均被访问一次，而且仅被访问一次。

遍历的实质：对二叉树进行线性化的过程，将非线性化结构排成一个线性序列。

~~~cpp
void PreOrder(BiTree T){
  if(T){
    cout << T->data << endl;
    PreOrder(T->lchild);
    PreOrder(T->rchild);
  }
}

void InOrder(BiTree T){
  if(T){
    InOrder(T->lchild);
    cout << T->data << endl;
    InOrder(T->rchild);
  }
}

void PostOrder(BiTree T){
  if(T){
    PostOrder(T->lchild);
    PostOrder(T->rchild);
    cout << T->data << endl;
  }
}
~~~



#### 非递归遍历二叉树 - 栈

~~~cpp
void InOrderTraverse(BiTree T){
  InitStack(S);
  p = T;
  q = new BiTNode;
  while( p || !StackEmpty(S)){
    if(p){
      Push(S, p);
      p = p->lchild;
    }else{
      Pop(S, q);
      cout << q->data << endl;
      p = q->rchild;
    }
  }
}
~~~



#### 先序遍历的顺序建立二叉树

~~~cpp
void CreateBiTree(BiTree &T){
  cin >> ch;
  if(ch == '#') T = NULL;
  else{
    T = new BiTNode;
    T->data = ch;
    CreateBiTree(T->lchild);
    CreateBiTree(T->rchild);
  }
}

// 读入字符顺序 ABC##DE#G##F###
~~~



#### 复制二叉树

~~~cpp
void Copy(BiTree T, BiTree newT){
  if(T == NULL) newT = NULL;
  else{
    newT = new BiTNode;
    newT->data = T->data;
    Copy(T->lchild, newT->lchild);
    Copy(T->rchild, newT->rchild);
  }
}
~~~





#### 计算二叉树深度

~~~cpp
int Depth(BiTree T){
  if(T == NULL) return 0;
  else{
    m = Depth(T->lchild);
    n = Depth(T->rchild);
    if(m > n) return m+1;
   	return n+1;
  }
}
~~~



#### 统计二叉树的结点数

~~~cpp
int Count(BiTree T){
  if(T == NULL) return 0;
  else
    return Count(T->lchild) + Count(T->rchild) + 1;
}
~~~





#### 线索二叉树 数据结构

~~~cpp
typedef struct BiThrNode{
  TElemType data;
  struct BiThrNode *lchild *rchild;
  int LTag, RTag;
}BiThrNode, *BiThrTree;
~~~



#### 构造线索二叉树

**构造线索二叉树的本质**：是将二叉链表中空指针改为指向前驱或后继的线索，而前驱或后继的信息只有在遍历的时候才能得到，因此线索化的过程即为在遍历过程中修改空指针的过程。



##### 以结点p为根的子树中序线索化

**相关指针说明**：设置一个指针`pre`始终指向当前访问结点的前一结点，指针`p`指向当前访问的结点，由此记录遍历过程中访问结点的先后关系。

**算法步骤**：

1. 初始化pre指针，将其右孩子置为空，便于在树的最左点开始建立线索；
2. 若p非空，左子树递归线索化；
3. 若p的左孩子为空，给p加上左线索，将其LTag置为1，让p左孩子指针指向pre（前驱）；否则p的LTag置为0；
4. 若pre的右孩子为空，给pre加上左线索，将其RTag置为1，让pre右孩子指针指向p（后继）；否则pre的RTag置为0；
5. 将pre指向的刚访问过的结点p；
6. 右子树递归线索化。

**算法描述**

~~~cpp
void InThreading(BiThrTree p){
  BiThrNode *pre = new BiThrNode;
  pre.rchild = NULL;
  if(p){
    InThreading(p->lchild);
    if(!p->lchild){
      p->LTag = 1;
      p->lchild = pre;
    }else p->LTag = 0;
    
    if(!pre->rchild){
      pre->RTag = 1;
      pre->rchild = pre;
    }else p->RTag = 0;
    pre = p;
    InThreading(p->rchild);
  }
  
}
~~~



##### 带头结点的二叉树中序线索化

**算法描述**

~~~cpp
void InOrderThreading(BiThrTree &Thrt, BiThrTree T){
  Thrt = new BiThrNode; // 建立头结点
  Thrt->LTag = 0;				// 头结点有左孩子，若树非空，则其左孩子为树根
  Thrt->RTag = 1;				// 头结点的右孩子指针为右线索
  if(!T) Thrt->lchild = Thrt; // 若树为空，则左指针也指向自己
  else{
    Thrt->lchild = T;		// 头结点的左孩子指向根
    pre = Thrt;					// pre初值指向头结点
    InThreading(T);			// 对以T为根的二叉树进行中序线索化
    pre->rchild = Thrt;	// 线索化完成之后pre指向最右结点，pre的右线索指向头结点
    pre->RTag = 1;			// 最右结点右孩子是线索
    Thrt->rchild = pre;	// 将头结点的右线索指向pre
  }
}
~~~





##### 线索二叉树的遍历

时间复杂度O(n)，空间复杂度O(1)

~~~cpp
void InOrderTraverse_Thr(BiThrTree T){
  p = T->lchild; // 指向根节点
  while(p != T){ // 空树或遍历结束时
    while(p->LTag == 0) p = p->lchild; // 找到当前的最左端的左孩子
    cout << p->data;
    while(p->RTag == 1 && p->rchild != T){ //找其后驱结点且为遍历为到最后一结点
      p = p->rchild;
      cout << p->data;
    }
    p = p.rchild; // 转向p的右结点
  }
}
~~~



### 树和森林

#### 树的存储结构

##### 双亲表示法 顺序存储

```cpp
#define MAX_SIZE 100
typedef struct {
  ElemtType data;
  int parent;
}PTNode;

typedef struct {
  PTNode nodes[MAX_SIZE];
  int n;
}PTree;
```



##### 孩子表示法(顺序+链式存储)

~~~cpp
#define MAX_SIZE 100
typedef struct CTNode{
  int child;
  struct CTNode *next;
}CTNode;

typedef struct {
  TElemType data;
  struct  CTNode *firstNode;
}CTBox;

typedef struct {
  CTBox nodes[MAX_SIZE];
  int n, r;
}CTree
~~~



##### 孩子兄弟表示法 链式存储

又称二叉树表示法，或二叉链表表示法，即以二叉链表做树的存储结构。

这种存储结构的优点是它和二叉树的二叉链表表示完全一样，便于将一般的树结构转换为二叉树进行处理，利用二叉树的算法来实现对树的操作。	

~~~cpp
typedef struct CSNode{
  ElemType data;
  struct CSNode *firstchild, *nextsibling;
}CSNode, *CSTree
~~~



![image-20220718090353079](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220718090353079.png)

#### 树、森林与二叉树的转换

由于二叉树和树都可以用二叉链表作为存储结构，因此以二叉链表作为媒介可以导出树与二叉树的对应关系，即给定一棵树，可以找到唯一的一棵二叉树与对应。

树转化为二叉树的规则（左孩子右兄弟）：每个结点的左指针指向第一个孩子，右指针指向它在树中相邻的右兄弟。



#### 树和森林的遍历

###### 树的遍历

~~~cpp
// 深度遍历
// 先根
void PreOrder(TreeNode *R){
   if(R != NULL){
      visit(R);
    while((T = hasOffspring(R)) != NULL) // 还有下一个子树T
      PreOrder(T)
  }
}

// 后根
void PostOrder(TreeNode *R){
  if(R != NULL){
    while((T = hasOffspring(R)) != NULL)
      PostOrder(T)
   visit(R);
  }
}

// 树的先根遍历与其相应的二叉树的先序序列相同
// 树的后根遍历与其相应的二叉树的中序序列相同 


// 层次遍历 - 广度遍历
void LevelTraversal(TreeNode *R){
  if(R != NULL){
    EnQueue(Q, R);
    while(EmptyQueue(Q)){
      DeQueue(Q, s);
     	visit(s);
      for(t = s.firstchild; t != NULL; t = s.nextsibling){
        EnQueue(Q, t);
      }
    }
  }
}
~~~



###### 树和森林的遍历与二叉树遍历关系表

![image-20220718093931102](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220718093931102.png)



### 哈夫曼树

![image-20220720083825138](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220720083825138.png)

> 哈夫曼树又称最优树，是一列带权路径长度最短的树。广泛用通信编码。



##### 名词解释

1. 路径：从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径；

2. 路径长度：路径上的分支数目；

3. 树的路径长度：从树根到每一结点的路径长度之和；

4. 权：赋予某个实体的量，是对实体的某个或某些属性的数值化描述。数据结构中国，实体有结点（元素）和边（关系）两个大类，所以对应有结点权和边权。具体含义有具体情况而定；

5. 结点的带权路径长度：从该结点到树根之间的路径长度（经过的边数）与结点上权的乘积；

6. 树的带权路径长度：树中所有结点的带权路径长度之和（WPL，Weighted Path Length)；
   $$
   WPL = \sum_{i=1}^n w_il_i
   $$

7. 哈夫曼树：假设有m个权值{w<sub>1</sub>, w<sub>2</sub>, ..., w<sub>m</sub>}，可以构造一棵含n个叶子结点的二叉树，每个叶子结点的权为w<sub>i</sub>，其中带权路劲长度WPL最下的二叉树称作最优二叉树或哈夫曼树。



##### 哈夫曼树的特点

1. 每个初始结点最终都成为叶结点且权值越小的结点到根结点的路径长度越大；
2. 每个结点之间会两两合并即合并n-1一次，哈夫曼树的结点总数为2n-1；
3. 哈夫曼树不存在度为1的结点；
4. 哈夫曼树并不唯一，但WPL必然相同且最优。



##### 哈夫曼树的构造

1. 将n个结点分别作为n棵含有一个结点的二叉树，构成森林F；
2. 构造一个新结点，从F中选取两棵根结点权值最小的数作为新结点的左右子树，并将新结点的权值置为左右两棵子树的权值之和；
3. 从F中删除刚选出的两棵子树，同时将新得到的数加入F中；
4. 重复步骤2、3，直至F中只剩下一棵树为止；



##### 哈夫曼编码

前缀编码，没有一个编码的是另一个编码的前缀。

字符集中的每个字符作为一个**叶子结点**，各个字符出现的频度作为**结点的权值**。



![image-20220720090709940](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220720090709940.png)





### 二叉排序树

![image-20220718105331696](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220718105331696.png)

![image-20220718105515948](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220718105515948.png)

##### 查找

![image-20220718105815737](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220718105815737.png)

![image-20220718105928093](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220718105928093.png)

每多一层的递归都会在函数调用栈里面多分配一片空间，因此递归的效率更低；

###### 递归实现二叉树查找

1. 若二叉排序树为空，则查找失败，返回空指针；
2. 若二叉排序树非空，将定值key与根节点的关键字T-data.key进行比较；
   1. 若key等于T->data.key，则查找成功，返回根节点；
   2. 若key小于T->data.key，则递归查找左子树，反之则递归右子树。

~~~cpp
// 循环实现
BSTree SearchBST(BSTree T, KeyType key){
  while(T != NULL || key != T->data.key){
    if(Key < T->data.key)  T = T->lchild;
  else T = T->rchild;
  }
 	return T;
 }
// 递归实现
BSTree SearchBST(BSTree T, KeyType key){
  if(!T || key == T->data.key) return T;
	if(Key < T->data.key) return SearchBST(T->lchild, key);
  else return SearchBST(T->rchild, key);
}
~~~



##### 插入

![image-20220718110839756](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220718110839756.png)



##### 构造

![image-20220718111105003](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220718111105003.png)



##### 删除

![image-20220718111345250](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220718111345250.png)

![image-20220718111317588](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220718111317588.png)

![image-20220718111535911](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220718111535911.png)

 



##### 查找效率分析

![image-20220718112057601](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220718112057601.png)

![image-20220718112254274](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220718112254274.png)

![image-20220718112339985](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220718112339985.png)





### 平衡二叉树

![image-20220721090910932](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220721090910932.png)

平衡二叉树（Balanced Binary Tree)，简称平衡二叉树（AVL)树上任一结点的左子树和右子树高度之差不超过1；

结点的平衡因子= 左子树高 - 右子树高

只要任一结点的平衡因子绝对值大于1就不是平衡二叉树。



![image-20220721091424360](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220721091424360.png)

恢复平衡、保持二叉排序树的特性；（左子树结点值 < 根节点值 < 右子树的结点值  ）

![image-20220721093018700](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220721093018700.png)

![image-20220721093711890](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220721093711890.png)



![image-20220721094624141](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220721094624141.png)

![image-20220721094749553](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220721094749553.png)



~~~cpp
/**
* @Time ：  2022/7/21 19:14
* @Auth ： Reddy · Fan
* @File ：BiTree.cpp
* @Description :  王道 - 树 思维拓展 打印树路径
*/
#include <iostream>
#include <stack>
using namespace std;

stack<int> S;
typedef struct BiTNode {
    int data;
    struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;

void CreateBiTree(BiTree &T) {
    int ch;
    cin >> ch;
    if (ch == -1) T = NULL;
    else {
        T = new BiTNode;
        T->data = ch;
        CreateBiTree(T->lchild);
        CreateBiTree(T->rchild);
    }
}

//10
//5
//4
//-1
//-1
//7
//-1
//-1
//12
//-1
//-1

// todo: 树的分支过多时，此算法可能失效
void SeekRoute(BiTree &T, int data, int sum = 0){
    if (T != NULL) {
        sum += T->data;
        if (data == sum && !T->rchild && !T->rchild) {
            cout << T->data << '\t';
            while (!S.empty()) {
                cout << S.top() << '\t';
                S.pop();
            }
            putchar('\n');
            return;
        }
        if (sum > data || (!T->rchild && !T->rchild)) {
            S.pop();
            return;
        }
        if (T->lchild) {
            S.push(T->data);
            SeekRoute(T->lchild, data, sum);
        }
        if (T->rchild) {
            S.push(T->data);
            SeekRoute(T->rchild, data, sum);
        }
    }
}

int main() {
    BiTree  T;
    CreateBiTree(T);
    SeekRoute(T, 22);
    return 0;
}
~~~






## 并查集

并查集是一种简答的集合，通常用树（森林）的双亲表示作为并查集的存储结构，每个集合用一棵树表示。

所有表示子集合的树，构成全集合的森林；

相关表示

1. 通常用数组元素表示下标代表元素名；
2. 用根结点的下标代表子集合名；
3. 根结点的双亲结点为负数；



## 第六章 图

> 图G由顶点集V和边集E组成，记为G=(V, E)
>
> 线性表可以是空表，树可以是空树，但图不可是空树，即顶点集一定是非空集



1. V(G)表示图G中的顶点的有限非空集；
2. E(G)表示图G中顶点之间的关系（边）集合；



### 名词解释

1. 子图：两图G=(V, E)和G<sup>’</sup>=(V<sup>’</sup>, E)<sup>’</sup>， 若V<sup>’</sup>是V的子集，且E<sup>’</sup>是E的子集，则称G<sup>’</sup>是G的子图；
2. 生成子图：V(G<sup>’</sup>) =V(G)；
3. 无向完全图：具有n(n-1)/2条边的无向图；
4. 有向完全图：具有n(n-1)条弧的有向图；
5. 稀疏图和稠密图：有很少条边或弧且`e<nlog<sub>2</sub>n的`图，反之稠密图；
6. 权：每条边可以表上某种含义的数值；
7. 网：可以表示从一个顶点到另一个顶点的距离或耗费的权；
8. 邻接点：对于无向图，如果图的边（v, v<sup>’</sup>)∈E，则称顶点v和v<sup>’</sup>互相邻接；
9. 度：顶点关联边的数目；
10. 入度：指向某个顶点的边的数目；
11. 路径：一个顶点到另一个顶点的顶点序列；
12. 路径长度：一条路径上经过的边或弧的数目；
13. 出度：某个顶点指向其他顶点的边的数目；
14. 回路或环：第一个顶点和最后一个顶点相同的路径；
15. 简单路径：序列中顶点不重复出现的路径；
16. 简单回路或简单环：除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路；
17. 连通：在无向图中，从顶点v到顶点v<sup>’</sup>有路径，则称v和v<sup>’</sup>是连通的；
18. 连通图：图中任意两个顶点v<sub>i</sub>、v<sub>j</sub>∈V，v<sub>i</sub>和v<sub>j</sub>都是连通的，则图为连通图；
19. 连通分量：**无向图**中的极大连通子图称为连通分量（子图必须连通，且包含尽可能多的顶点和边）；
20. 强连通图：在有向图G中，如果对于每一对v<sub>i</sub>、v<sub>j</sub>∈V，v<sub>i</sub>≠v<sub>j</sub>，从v<sub>i</sub>到v<sub>j</sub>和v<sub>j</sub>到v<sub>i</sub>都存在路径；
21. 强连通分量：有向图中极大连通子图称为有向图的强连通分量；
22. 生成树：**连通图的生成树**是包含图中全部顶点的一个**极小（边尽可能的少，但要保持连通）**连通子图（顶点n， n-1条边）。
23. 生成森林：在连通图中，**连通分量的生成树**构成了非连通图的生成森林。
24. 有向树：有一个顶点的入度为0，其余顶点的入度为1的有向图；

![image-20220721204034341](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220721204034341.png)

![image-20220721210654216](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220721210654216.png)



### 图的存储

> **所选择的存储结构应适用于待求解的问题**：根据不同图的结构和算法，采用不同的存储方式将对程序的效率产生相当大的影响。



#### 邻接矩阵

用一个一维数组存储图中的**顶点信息**，用一个二维数组存储图中**边的信息**，存储顶点之间**邻接关系**的二维数组称为邻接矩阵。

~~~cpp
#define MAX_VERTEX_NUM 100
typdef struct{
  char Vex[MAX_VERTEX_NUM];
  int Edege[MAX_VERTEX_NUM][MAX_VERTEX_NUM];
  int vexnum, arcnum; // 当前顶点数和边数/弧数
}MGraph;
~~~

![image-20220723110229448](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220723110229448.png)



##### 邻接矩阵的特点

1. 无向图第i个结点的度：  第i行或第i列的非零元素的个数；
2. 有向图第i个结点的度：它的入度和出度之和

   * 出度：第i行的非零元素；

   * 入度：第i列的非零元素；
3. 无向图的临界矩阵一定是一个**对称矩阵并且唯一**，因此在存储临界矩阵是只需要存储只需存储上（或下）三角矩阵的元素；
4. 临界矩阵很容易确定两个顶点之间是否存在边，但确定图中有多少条边，时间代价很大；
5. 临界矩阵适合稠密度，不适用于稀疏图；
6. 若图的邻接矩阵为A，A<sup>n</sup>的元素A<sup>n</sup>\[i\]\[j\]等于顶点i到顶点j的长度为n的路径数目(A<sup>n</sup>，顶点0到顶点3长度为n的路径有`x`条)；
7. 临界矩阵表示唯一。





![image-20220722112059704](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220722112059704.png)





#### 邻接表

邻接表结合了顺序存储和链式存储方法，大大降低了空间的不必要浪费，解决了邻接矩阵存储稀疏图空间浪费的问题。

邻接表：试图图中的每个顶点建立一个单链表，第i个单链表中结点表示依附于顶点的边，这个单链表称为顶点的边表。边表的头指针和顶点的数据信息采用顺序存储。



数据结构

~~~cpp
#define MAX_VERTEX_NUM 100
// 边/弧	
typedef struct ArcNode{
  int adjvex; // 边指向的结点
  struct ArcNode next; // 下一下边/弧
  // InfoType info  // 边权值
}ArcNode;

typedef struct VNode{
  VertexType data;
  ArcNode *first;
}VNode, AdjList[MAX_VERTEX_NUM];

typedef struct {
  AdjList vertices; // 邻接表
  int vexnum, arcnum;
}ALGraph;
~~~



##### 邻接表的特点

1. 若存储无向图，则所需的存储空间位O(|V|+2|E|)，若存储有向图O(|V|+|E|)，前者边的2倍，是由于无向图中每条边在邻接表中出现两次；
2. 对于稀疏图极大节省空间；
3. 给定一顶点，很容易找出它的所有邻边，但要确定两个顶点是否存在边，需要在相应结点对应的边表中查找，效率较低；
4. 在有向图的邻接表中，求一个顶点的**出度**只需计算邻接表的结点个数，但求其顶点**入度**需要遍历全部的邻接表。解决查找入度困难的方法，可以使用逆邻接表的存储方式；
5. 邻接表的表示并不唯一，因为在每个顶点对应的单链表中，各边结点的连接次序可以是任意的，取决于建立邻接表的算法以及边的输入次序。



![image-20220722112331386](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220722112331386.png)



![image-20220723105342532](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220723105342532.png)



#### 十字链表

十字链表是有向图的一种链式存储结构。在十字链表中，对应于有向图中的每条弧有一个结点，对应于每个顶点也有一个结点。

![image-20220723110121425](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220723110121425.png)

##### 弧结点的五个域

1. 尾域`tailvex`和头域`headvex`分别指示弧尾和弧头这两个顶点在图中的位置；
2. 链域`hlink`指向弧头相同的下一个弧；
3. 链域`tlink`指向弧尾相同的下一个弧；
4. `info`域指向该弧的相关信息；



##### 顶点域

1. `data`域存储顶点相关数据信息；
2. `firstin`和`firstout`域分别指向该顶点为弧头或弧尾的第一个弧结点；



##### 特点

1. 弧头相同的弧在同一链表上，弧尾相同的弧也在同一链表上；
2. 顶点结点之间是顺序存储；
3. 在十字链表中，容易找到以某一顶点为**尾**或**头**的弧，因此容易求得顶点的出度和入度；
4. 十字链表的表示是不唯一的，但一个十字链表表示确定的一个图。



#### 邻接多重表

邻接多重表是无向图的一种链式存储结构。

解决的问题

邻接表中，容易求得顶点和边的各种信息，但在邻接表中求两个顶点之间是否存在边，而对边执行删除等操作时，需要分别在两个顶点的边表中遍历，效率较低。



![image-20220723110659660](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220723110659660.png)

##### 边域

1. `mark`标志域：用以标记该条边是否被搜索过；
2. `ivex`和`jvex`域：为该边依附的两个顶点在图中的位置；
3. `ilink`域：指向下一条依附于顶点ivex的边；
4. `jlink域`：指向下一条依附于顶点jvex的边；
5. `info`域：为指向和边相关的各种信息的指针域。



##### 顶点域

1. `data`域：存储该顶点的相关信息；
2. `firstedge`：指示第一条依附于该顶点的边；



##### 邻接多重表特点

1. 所有依附于同一顶点的边串联在同一链表中，由于每条边依附于两个顶点，因此每个边结点同时链接两个链表；
2. 对于无向图而言，其邻接多重光标和邻接表的差别仅在于，同一条边在邻接表中用两个顶点表示，而在邻接多重表中只有一个结点。



![image-20220723112207109](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220723112207109.png)

### 图的基本操作

> 图的基本操作独立于图的存储结构。对于不同的存储方法，操作算法的具体实现会有着不同的性能。**在设计具体算法实现时，应考虑采用何种存储方式的算法效率会更高。**



1. Adjancent(G, x, y)
2. Neighbors(G, x)
3. InsertVertex(G, x)
4. DeleteVertex(G, x)
5. AddEdge(G, x, y)
6. RemoveEdge(G, x, y)
7. FirstNeighbor(G, x)
8. NextNeighbor(G, x, y)
9. Get_edge_value(G, x, y)
10. Set_dege_value(G, x, y)



### 图的遍历



#### 广度优先搜索

~~~cpp
bool visited[MAX_VERTEX_NUM];
 

void BFSTraverse(Graph &G){
  for(i = 0; i < G.vexnum; ++i)
    visited[i] = false;
  for(i = 0; i < G.vexnum; ++i)
    if(!visisted[i])
      BFS(G, i);
}

void BFS(Graph &G, int v){
  InitQueue(Q);
  visited[v] = true;
  visit(v);
  EnQueue(G, w);
  while(!EmptyQueue(Q)){
    DeQueue(G, v);
    for(w = FirstNeighbor(G, v); w => 0; w = Nextneighbor(G, v, w)){
      if(!visisted[w]){
        visited[v] = true;
  			visit(v);
        EnQueue(G, w);
      }
    }
  }
}
~~~



##### 单源最短路径

原理：BFS是按照距离由近及远的方式来遍历图的(针对无权图)

~~~cpp
void BFS_MIN_DISTANCE(Graph &G, int u){
  for(i = 0; i < G.vexnum; ++i)
    d[i] = ∞;
  visited[u] = true; 
  d[u] = 0;
  EnQueue(Q, u);
  while(!EmptyQueue(Q)){
    DeQueue(G, u);
    for(w = FirstNeighbor(G, u); w >= 0; w = NextNeighbor(G, u, w))
      if(!visited[w]){
        visited[w] = true;
        d[w] = d[u] + 1;
      }
  }
}
~~~



##### 广度优先生成树

邻接矩阵存储表示是唯一的，因此其广度优先树也是唯一的；

邻接表存储表示不唯一，其广度优先树也不唯一。



#### 深度优先搜索



~~~cpp
bool visited[MAX_VERTEX_NUM];
 

void DFSTraverse(Graph &G){
  for(i = 0; i < G.vexnum; ++i)
    visited[i] = false;
  for(i = 0; i < G.vexnum; ++i)
    if(!visisted[i])
      DFS(G, i);
}


void DFS(Graph &G, int v){
  visited[v] = true;
  visit(v);
  for(w = FirstNeighbor(G, u); w >= 0; w = NextNeighbor(G, u, w))
     if(!visited[w]){
       BFS(G, w);
     }
}

~~~



##### 栈实现深度遍历

~~~cpp
// 由于使用了栈遍历方式从右端到左端进行
void DFS_NON_RC(Graph &G, int v){
  IninStack(S)
  for(i = 0; i < G.vexnum; ++i)
    visited[i] = false;
  Push(S, v);
  visited[v] = true;
  while(!EmptyStack(S)){
    Pop(S, v);
    visit(v);
    for(w = First(G, v); w >= 0; w = Next(G, v, w))
      if(!visited[w]){
        visited[w] = true;
        Push(S, w);
      }
  }
}
~~~



##### 深度优先生成树和生成森林

对连通图的调用产生生成树，若是非连通图产生生成森林；



##### 图的遍历和图的连通性

1. 无向图

   * 连通的：从任意结点出发，仅需一次就能访问图中所有结点；
   * 非连通的：从某一顶点出发，一次遍历只能访问完该顶点所在的连通分量的所有顶点；

2. 有向图

   从初始顶点到图中每个顶点都有路径，则能够访问图中所有顶点点，否则不能访问所有顶点。



### 图的应用

#### 最小生成树

一个连通图的生成树包含图中所有顶点，且只含尽可能少的边。

##### 性质

1. 生成树不是唯一的，可能有多个，但其对应的边权值之和是唯一的，且最小；
2. 最小生成树的边数为顶点数减1；



##### Prim  普里姆算法

> 按顶点距离最近扩展的最小生成树



基本思想

1. 从图中任一去一顶点加入树T，此时树中仅有一个顶点；
2. 选择一个离当前T中顶点集合距离最近的一个顶点，将其顶点和边加入树中；
3. 重复`步骤2`直至将图中所有顶点加入到树中，每次操作后树中顶点数和边数都会加1；



特点

​	时间复杂度为O(|V|<sup>2</sup>)，不依赖与边|E|，适合求解**边稠密**的图的最小生成树。

~~~cpp
void Prim(G, T){
  T = ∅;
  U = {w};
  while((V - U) != ∅){
    U = U ∪ {v};			 // 顶点归树
    T = T ∪ {(u, v)}； // 边归树
  }
}
~~~







##### Kruskal 克鲁斯卡尔算法

> 按权值递增次序选择合适的边

基本思想

1. 初始化时只有n个顶点而无边的非连通图T = {V, {}}，每个顶点自成一个连通分量；
2. 根据边的权值由小到大的顺序，不断选取当前未被选取过且权值最小的边，若该边依附的顶点落在不同的连通分量上，则将此边加入T，否则舍弃此边选择下一条权值最小的边；
3. 以此类推重复`步骤2`，直至所有顶点都在一个连通分量上。



特点

时间复杂度O(|E|log|E|)，可以用**并查集**来描述最小生成树，适合于**边稀疏而顶点多**的图。

~~~cpp
void Kruskal(V, T){
  T = V;
  numS = n; //连通分量树
  while(numS > 1){
    // 从E中取出权值最小的边(v, u)
    if(v和u属于T中不同的连通分量){
      T = T ∪ {(u, v)}；
    	numS--;
    }
  }
}
~~~



#### 最短路径

> 广度优先搜索查找最短路径只是针对于无权图。
>
> 带权图的最短路径：把从一个顶点到图中任意顶点v的一条路径所经过边上的权值之和，定义为路径的带权路径长度，把其中最短的带权路径长度称为**最短路径**



##### 最短路径类别

1. 单源最短路径：某一顶点到其他各顶点的最短路径；
2. 求每对顶点间的最短路径；



##### 单源最短路径 - Dijkstra

基本思想：设计一个集合S记录**已求得的最短路长度的顶点**，初始时将源点v<sub>0</sub>放入S，集合S每并入一个顶点v<sub>i</sub>（当前V-S集合中路径长度最短的顶点），都要修改源点V<sub>0</sub>到**V-S集合中顶点的当前路径长度值**，直至所有顶点全部并入S中。

![image-20220726110753953](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220726110753953.png)

特点

1. 不适合负权值



##### 每对顶点间的最短路径 - Floyed

对于各边权值均大于0的带权有向图，对任意两个顶点v<sub>i</sub>≠v<sub>j</sub>，要求求出v<sub>i</sub>到v<sub>j</sub>的最短路径和路径长度。

基本思想：递推的产生一个n阶方阵序列A<sup>(-1)</sup>,A<sup>(0)</sup>,...,A<sup>(k)</sup>,...,A<sup>(n-1)</sup>，其中A<sup>k</sup>\[i\]\[j\]表示从顶点v<sub>i</sub>到顶点v<sub>j</sub>的路径长度，k表示绕行第k个顶点的运算步骤。

1. 初始时，对于任意两个顶点v<sub>i</sub>和v<sub>j</sub>，若它们之间存在边，则以此边上的权值作为它们之间的最短路径，若它们之间不存在有向边，则以∞作为它们之间的最短路径。
2. 之后逐步在原路径中加入顶点k(k=0,1,2,...,n-1)作为中间结点，若增加中间顶点之后，得到的路径比原路径长度小，则以此代替原路径。

~~~cpp
for(k = 0; k < v.vexnum; ++k)
  for(i = 0; i < v.vexnum; ++i)
    for(j = 0; j < v.vexnum; ++j)
      if(A[i][j] > A[i][k] + [k][j]){
        A[i][j] = A[i][k] + [k][j];
        path[i][j] = k;
      }
~~~



![image-20220727094310578](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220727094310578.png)

![image-20220727095622520](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220727100331830.png)

通过path矩阵查找完整完整路径

![image-20220727181934996](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220727181934996.png)



实现

~~~cpp
/**
* @Time ：  2022/7/27 11:04
* @Auth ： Reddy · Fan
* @File ：find_full_path_Floyd.cpp
* @Description : 
*/
#include <iostream>

using namespace std;

#include<list>

typedef struct LNode {
    int data;
    struct LNode *next;

} LNode, *LinkList;

bool OrderInsert(LinkList &L, int data) {
    if (L == NULL) {
        L = new LNode;
        L->next = NULL;
        L->data = data;
        return true;
    }
    LinkList p = L;
    while (p->next != NULL)p = p->next;
    LinkList q = new LNode;
    q->data = data;
    q->next = NULL;
    p->next = q;
    return true;
}

bool InsertPassByValue(LinkList &L, int value, int data) {
    if (L == NULL) return false;
    LinkList p = L, q = p->next;
    while (p != NULL && value != p->data) {
        p = p->next;
        q = q->next;
    }
    if (p == NULL) return false;
    LinkList s = new LNode;
    s->data = data;
    s->next = p->next;
    p->next = s;
    return true;
}

//不带头结点遍历
void TraverseList2(LinkList L) {
    LinkList p = L;
    while (p) {
        printf("%d\t", p->data);
        p = p->next;
    }
    putchar('\n');
}

void FindFullPath(int path[][5], int begin, int end, LinkList &L) {
    if (path[begin][end] == -1) return;
    InsertPassByValue(L, begin, path[begin][end]);
    FindFullPath(path, begin, path[begin][end], L);
    FindFullPath(path, path[begin][end], end, L);

}


int main() {
    int path[][5] = {
            {-1, 2,  -1, 2,  3},
            {-1, -1, -1, -1, 3},
            {-1, -1, -1, 1,  3},
            {-1, -1, -1, -1, -1},
            {-1, -1, -1, -1, -1},
    };
    LinkList L = NULL;
    OrderInsert(L, 2);
    OrderInsert(L, 4);
    FindFullPath(path, 2, 4, L);
    TraverseList2(L);

    return 0;
}
~~~





![image-20220727095710787](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220727095710787.png)

![image-20220727095907743](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220727095907743.png)

#### 拓扑排序

##### 有向无环图

有向图中不存在环，则则称为有向无向图，简称DAG图

特点：

1. 顶点中不存在重复的操作数；
2. 最终形态不唯一



##### 解题步骤

1. 把各操作数不重复低排成一排；
2. 标出各个运算符的生效顺序；
3. 按顺序加入运算符，注意`分层`
4. 自底向上逐层同层的运算是否可以合体



![image-20220728090604873](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220728090604873.png)



![image-20220728090758930](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220728090758930.png)



AOV网

> AOV(Activity On Vertex Network)， 用顶点表示活动的网
>
> 用DAG图表示一个工程。顶点表示活动，邮箱变<V<sub>i</sub>，V<sub>j</sub>>表示活动V<sub>i</sub>必须先于V<sub>j</sub>进行。



拓扑排序：找到做事的先后顺序





特点：

1. 存在回路的图，不存在拓扑排序序列；
2. 拓扑排序中count计数=顶点数
3. 邻接表：顶点指出的边，其顶点是邻接点的入度。逆邻接表：其邻接点指向顶点的，顶点是邻接点的出度



![image-20220728100835134](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220728100835134.png)

经常用于判断图是否有环

#### 关键路径

在带权有向图中，，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销，称之为用边表示活动的网，AOE（Activity On Edge Network)



![image-20220728101259795](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220728101259795.png)



![image-20220728101504192](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220728101504192.png)



![image-20220728103350625](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220728103350625.png)



![image-20220728103925312](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220728103925312.png)



![image-20220728104252908](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220728104252908.png)



![image-20220728104550111](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220728104550111.png)



![image-20220728105534266](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220728105534266.png)



![image-20220728105556212](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220728105556212.png)



![image-20220728105716755](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220728105716755.png)



![image-20220728105841893](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220728105841893.png)



![image-20220728105953608](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220728105953608.png)



![image-20220728110118464](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220728110118464.png)



![image-20220728110142821](/Users/reddyfan/Library/Application Support/typora-user-images/image-20220728110142821.png)``



### 算法设计

#### 邻接表转换为邻接矩阵

此算法对于无向图，有向图均适用。

将图的顶点存在数组v[n]中，初始化邻接矩阵。

1. 遍历邻接表，在依次遍历顶点v[i]的边链表是，修改邻接矩阵第i行的元素值；
2. 若邻接表的结点值为j，则置为arcs[\i\]\[j\]=1。

~~~cpp
void adjacentListToadjcentMatrix(Graph &G, int arcs[M][N]){
  for(i = 0; i < G->vexnum; ++i){
    p = (G->v[i]).fisrtarc;
    while(p->next != NULL){
      arcs[i][p.adjvex] = 1;
      p = p->next;
    }
  }
}
~~~



#### 用邻接表输出从顶点V<sub>i</sub>到顶点V<sub>j</sub>的所有简单路径

基本思想：基于深度优先遍历算法，从顶点u出发，递归深度遍历图中结点，若访问到顶点，则输出该搜索路径上的顶点，为此，设置一个path数组来存放路径上的顶点，d表示路径长度（初始为1）；

path数组来存储经过的路径，d初始值为-1

~~~cpp
void FindPath(Graph &G, int u, int v, int path[], int d){
  path[++d] = u;
  visited[u] = 1;
  if(u == v) visit(path);
  p = G->adjList[d].firstarc;
  while(p != NULL){
    w = p->adjnext;
    if(!visited[w]) FindPath(G, w, v, path, d);
    p = p->adjnext;
  }
  visted[u] = 0; // 恢复环境，使该顶点可用
}
~~~



#### 以邻接表的表示判别有向图中是否存在顶点V<sub>i</sub>到顶点V<sub>j</sub>的路径

##### 深度优先

~~~cpp
void IsExistRoute_DFS(Graph &G, int i, int j, bool &flag){
  if(i == j){
    flag = true;
    return;
  }
  visited[i] = 1
  for(w = FirstAdj(G, i); w => 0; w = NextAdj(G, i, j)){
    if(!visited[w])
      IsExistRoute_DFS(G, w, j, flag);
  }
}
~~~



##### 广度优先

~~~cpp
int IsExistRoute_BFS(Graph &G, int i, int j){
  InitQueue(G);
  EnQueue(G, i);
  while(!EmptyQueue(G)){
    DeQueue(G, i);
    visited[i] = 1
    for(w = FirstAdj(G, i); w => 0; w = NextAdj(G, i, w)){
      if(w == j) return true;
    	if(!visited[w]){
        EnQueue(G, w);
        visited[w] = 1;
      }
  }
}
 return false;
}
~~~



